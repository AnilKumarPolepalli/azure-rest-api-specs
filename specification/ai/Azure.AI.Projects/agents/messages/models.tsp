import "../tools/models.tsp";
import "@typespec/versioning";

namespace Azure.AI.Projects.Agents;

using TypeSpec.Versioning;

#suppress "@azure-tools/typespec-autorest/union-unsupported" "We intentionally want a union of string | array."
@doc("Because OpenAPI 2 doesnâ€™t fully support oneOf for 'string or array,' we suppress the rule.")
union CreateMessageContent {
  @doc("If callers only have a quick text message, they can pass a plain string here.")
  text: string,

  @doc("For 'rich' content, callers can pass an array of typed content blocks (e.g. text, image_file, image_url).")
  blocks: MessageContentBlockInput[],
}

@doc("For the block's 'type' property, we define an open union with a fallback string to satisfy the no-string-discriminator rule.")
union MessageBlockType {
  @doc("A text content block.")
  text: "text",

  @doc("An internally uploaded image file.")
  image_file: "image_file",

  @doc("An externally hosted image URL.")
  image_url: "image_url",

  @doc("Fallback for unrecognized types the service might return in the future.")
  string,
}

@doc("An abstract base for creation-time 'blocks' that can be text or images. We use @discriminator('type') but make 'type' an open union.")
@discriminator("type")
model MessageContentBlockInput {
  @doc("Must be one of 'text', 'image_file', or 'image_url' (or a fallback string).")
  type: MessageBlockType;
}

@doc("Creation-time text block.")
model MessageTextBlockInput extends MessageContentBlockInput {
  @doc("Always 'text'.")
  type: "text";

  @doc("The text content.")
  text: string;
}

@doc("Creation-time image-file block.")
model MessageImageFileBlockInput extends MessageContentBlockInput {
  @doc("Always 'image_file'.")
  type: "image_file";

  @doc("References an uploaded image by file ID.")
  @encodedName("application/json", "image_file")
  imageFile: MessageImageFileParam;
}

@doc("Creation-time image-URL block.")
model MessageImageUrlBlockInput extends MessageContentBlockInput {
  @doc("Always 'image_url'.")
  type: "image_url";

  @doc("References an external image by URL.")
  @encodedName("application/json", "image_url")
  imageUrl: MessageImageUrlParam;
}

@doc("Represents an open union for the image detail level: 'auto', 'low', 'high', or an unknown string.")
union ImageDetailLevel {
  @doc("Automatic or default level of detail.")
  auto: "auto",

  @doc("Low detail: uses fewer tokens.")
  low: "low",

  @doc("High detail: uses more tokens (including potentially more cost).")
  high: "high",

  @doc("Fallback for unrecognized values the service might return in the future.")
  string,
}

@doc("Parameter for an image file (by ID) at creation time.")
model MessageImageFileParam {
  @doc("File ID for the uploaded image.")
  fileId: string;

  @doc("Specifies the requested detail level for the image.")
  detail?: ImageDetailLevel;
}

@doc("Parameter for an external image URL at creation time.")
model MessageImageUrlParam {
  @doc("The externally accessible image URL.")
  url: string;

  @doc("Specifies the requested detail level for the image. Default is 'auto'.")
  detail?: ImageDetailLevel;
}

/** A single message within an agent thread, as provided during that thread's creation for its initial state. */
model ThreadMessageOptions {
  /**
   * The role of the entity that is creating the message. Allowed values include:
   *   - `user`: Indicates the message is sent by an actual user and should be used in most
   *    cases to represent user-generated messages.
   *   - `assistant`: Indicates the message is generated by the agent. Use this value to insert
   *    messages from the agent into the
   *    conversation.
   */
  role: MessageRole;

  /**
   * The content of the initial message. This may be:
   *  - A basic string, if you only need text, or
   *  - An array of typed content blocks (text, image_file, image_url, etc.)
   */
  content: CreateMessageContent;

  /** A list of files attached to the message, and the tools they should be added to. */
  #suppress "@azure-tools/typespec-azure-core/no-nullable" "OpenAI uses explicit nullability, distinct from optionality"
  attachments?: MessageAttachment[] | null;

  ...OptionalNullableMetadata;
}

@doc("A single, existing message within an agent thread.")
model ThreadMessage {
  @doc("The identifier, which can be referenced in API endpoints.")
  id: string;

  @doc("The object type, which is always 'thread.message'.")
  object: "thread.message";

  @encodedName("application/json", "created_at")
  @encode(DateTimeKnownEncoding.unixTimestamp, int32)
  @doc("The Unix timestamp, in seconds, representing when this object was created.")
  createdAt: utcDateTime;

  @encodedName("application/json", "thread_id")
  @doc("The ID of the thread that this message belongs to.")
  threadId: string;

  /** The status of the message. */
  status: MessageStatus;

  /** On an incomplete message, details about why the message is incomplete. */
  #suppress "@azure-tools/typespec-azure-core/no-nullable" "OpenAI uses explicit nullability, distinct from optionality"
  @encodedName("application/json", "incomplete_details")
  incompleteDetails: MessageIncompleteDetails | null;

  /** The Unix timestamp (in seconds) for when the message was completed. */
  #suppress "@azure-tools/typespec-azure-core/no-nullable" "OpenAI uses explicit nullability, distinct from optionality"
  @encode(DateTimeKnownEncoding.unixTimestamp, int32)
  @encodedName("application/json", "completed_at")
  completedAt: utcDateTime | null;

  /** The Unix timestamp (in seconds) for when the message was marked as incomplete. */
  #suppress "@azure-tools/typespec-azure-core/no-nullable" "OpenAI uses explicit nullability, distinct from optionality"
  @encode(DateTimeKnownEncoding.unixTimestamp, int32)
  @encodedName("application/json", "incomplete_at")
  incompleteAt: utcDateTime | null;

  @doc("The role associated with the agent thread message.")
  role: MessageRole;

  @doc("The list of content items associated with the agent thread message.")
  content: MessageContent[];

  #suppress "@azure-tools/typespec-azure-core/no-nullable" "OpenAI uses explicit nullability, distinct from optionality"
  @encodedName("application/json", "assistant_id")
  @doc("If applicable, the ID of the agent that authored this message.")
  assistantId: string | null;

  #suppress "@azure-tools/typespec-azure-core/no-nullable" "OpenAI uses explicit nullability, distinct from optionality"
  @encodedName("application/json", "run_id")
  @doc("If applicable, the ID of the run associated with the authoring of this message.")
  runId: string | null;

  /** A list of files attached to the message, and the tools they were added to. */
  #suppress "@azure-tools/typespec-azure-core/no-nullable" "OpenAI uses explicit nullability, distinct from optionality"
  attachments: MessageAttachment[] | null;

  ...RequiredNullableMetadata;
}

/** This describes to which tools a file has been attached. */
model MessageAttachment {
  /** The ID of the file to attach to the message. */
  @encodedName("application/json", "file_id")
  fileId?: string;

  /** The data source to be used. This option is mutually exclusive with fileId. */
  @doc("Azure asset ID.")
  @encodedName("application/json", "data_source")
  dataSource?: VectorStoreDataSource;

  /** The tools to add to this file. */
  tools: MessageAttachmentToolDefinition[];
}

/** The possible tools to which files will be added by this message */
#suppress "@azure-tools/typespec-autorest/union-unsupported" "This union is defined according to the OpenAI API"
union MessageAttachmentToolDefinition {
  CodeInterpreterToolDefinition | FileSearchToolDefinition,
}

// Message content types: "text" | "image_file"

@discriminator("type")
@doc("An abstract representation of a single item of thread message content.")
model MessageContent {
  #suppress "@azure-tools/typespec-azure-core/no-string-discriminator" "Existing"
  @doc("The object type.")
  type: string;
}

@doc("A representation of a textual item of thread message content.")
model MessageTextContent extends MessageContent {
  @doc("The object type, which is always 'text'.")
  type: "text";

  @doc("The text and associated annotations for this thread message content item.")
  text: MessageTextDetails;
}

@doc("A representation of image file content in a thread message.")
model MessageImageFileContent extends MessageContent {
  @doc("The object type, which is always 'image_file'.")
  type: "image_file";

  @encodedName("application/json", "image_file")
  @doc("The image file for this thread message content item.")
  imageFile: MessageImageFileDetails;
}

// Text content details

@doc("The text and associated annotations for a single item of agent thread message content.")
model MessageTextDetails {
  @doc("The text data.")
  value: string;

  @doc("A list of annotations associated with this text.")
  annotations: MessageTextAnnotation[];
}

// Annotations, used by text content: "file_citation" | "file_path" | "url_citation"

@discriminator("type")
@doc("An abstract representation of an annotation to text thread message content.")
model MessageTextAnnotation {
  #suppress "@azure-tools/typespec-azure-core/no-string-discriminator" "Existing"
  @doc("The object type.")
  type: string;

  @doc("The textual content associated with this text annotation item.")
  text: string;
}

// URL citation annotation + details

@doc("A citation within the message that points to a specific URL associated with the message. Generated when the agent uses tools such as 'bing_grounding' to search the Internet.")
model MessageTextUrlCitationAnnotation extends MessageTextAnnotation {
  @doc("The object type, which is always 'url_citation'.")
  type: "url_citation";

  @encodedName("application/json", "url_citation")
  @doc("The details of the URL citation.")
  urlCitation: MessageTextUrlCitationDetails;

  @encodedName("application/json", "start_index")
  @doc("The first text index associated with this text annotation.")
  startIndex?: int32;

  @encodedName("application/json", "end_index")
  @doc("The last text index associated with this text annotation.")
  endIndex?: int32;
}

@doc("A representation of a URL citation, as used in text thread message content.")
model MessageTextUrlCitationDetails {
  @doc("The URL associated with this citation.")
  url: string;

  @doc("The title of the URL.")
  title?: string;
}

// File citation annotation + details

@doc("A citation within the message that points to a specific quote from a specific File associated with the agent or the message. Generated when the agent uses the 'file_search' tool to search files.")
model MessageTextFileCitationAnnotation extends MessageTextAnnotation {
  @doc("The object type, which is always 'file_citation'.")
  type: "file_citation";

  @encodedName("application/json", "file_citation")
  @doc("""
    A citation within the message that points to a specific quote from a specific file.
    Generated when the agent uses the "file_search" tool to search files.
    """)
  fileCitation: MessageTextFileCitationDetails;

  @encodedName("application/json", "start_index")
  @doc("The first text index associated with this text annotation.")
  startIndex?: int32;

  @encodedName("application/json", "end_index")
  @doc("The last text index associated with this text annotation.")
  endIndex?: int32;
}

@doc("A representation of a file-based text citation, as used in a file-based annotation of text thread message content.")
model MessageTextFileCitationDetails {
  @encodedName("application/json", "file_id")
  @doc("The ID of the file associated with this citation.")
  fileId: string;

  @doc("The specific quote cited in the associated file.")
  quote: string;
}

// File path annotation + details

@doc("A citation within the message that points to a file located at a specific path.")
model MessageTextFilePathAnnotation extends MessageTextAnnotation {
  @doc("The object type, which is always 'file_path'.")
  type: "file_path";

  @encodedName("application/json", "file_path")
  @doc("A URL for the file that's generated when the agent used the code_interpreter tool to generate a file.")
  filePath: MessageTextFilePathDetails;

  @encodedName("application/json", "start_index")
  @doc("The first text index associated with this text annotation.")
  startIndex?: int32;

  @encodedName("application/json", "end_index")
  @doc("The last text index associated with this text annotation.")
  endIndex?: int32;
}

@doc("An encapsulation of an image file ID, as used by message image content.")
model MessageTextFilePathDetails {
  @doc("The ID of the specific file that the citation is from.")
  @encodedName("application/json", "file_id")
  fileId: string;
}

// Image file content details

@doc("An image reference, as represented in thread message content.")
model MessageImageFileDetails {
  @encodedName("application/json", "file_id")
  @doc("The ID for the file associated with this image.")
  fileId: string;
}

/** The possible execution status values for a thread message. */
union MessageStatus {
  string,

  /** A run is currently creating this message. */
  inProgress: "in_progress",

  /** This message is incomplete. See incomplete_details for more information. */
  incomplete: "incomplete",

  /** This message was successfully completed by a run. */
  completed: "completed",
}

/** Information providing additional detail about a message entering an incomplete status. */
model MessageIncompleteDetails {
  /** The provided reason describing why the message was marked as incomplete. */
  reason: MessageIncompleteDetailsReason;
}

/** A set of reasons describing why a message is marked as incomplete. */
union MessageIncompleteDetailsReason {
  string,

  /** The run generating the message was terminated due to content filter flagging. */
  contentFilter: "content_filter",

  /** The run generating the message exhausted available tokens before completion. */
  maxTokens: "max_tokens",

  /** The run generating the message was cancelled before completion. */
  runCancelled: "run_cancelled",

  /** The run generating the message failed. */
  runFailed: "run_failed",

  /** The run generating the message expired. */
  runExpired: "run_expired",
}

//
// These types are specifically used for streaming.
//

/** Represents a message delta i.e. any changed fields on a message during streaming. */
model MessageDeltaChunk {
  /** The identifier of the message, which can be referenced in API endpoints. */
  id: string;

  /** The object type, which is always `thread.message.delta`. */
  object: "thread.message.delta";

  /** The delta containing the fields that have changed on the Message. */
  delta: MessageDelta;
}

/** Represents the typed 'delta' payload within a streaming message delta chunk. */
model MessageDelta {
  /** The entity that produced the message. */
  role: MessageRole;

  /** The content of the message as an array of text and/or images. */
  content: MessageDeltaContent[];
}

/** The abstract base representation of a partial streamed message content payload. */
@discriminator("type")
model MessageDeltaContent {
  /** The index of the content part of the message. */
  index: int32;

  /** The type of content for this content part. */
  #suppress "@azure-tools/typespec-azure-core/no-string-discriminator" "Existing"
  type: string;
}

/** Represents a streamed image file content part within a streaming message delta chunk. */
model MessageDeltaImageFileContent extends MessageDeltaContent {
  /** The type of content for this content part, which is always "image_file." */
  type: "image_file";

  /** The image_file data. */
  @encodedName("application/json", "image_file")
  imageFile?: MessageDeltaImageFileContentObject;
}

/** Represents the 'image_file' payload within streaming image file content. */
model MessageDeltaImageFileContentObject {
  /** The file ID of the image in the message content. */
  @encodedName("application/json", "file_id")
  fileId?: string;
}

/** Represents a streamed text content part within a streaming message delta chunk. */
model MessageDeltaTextContent extends MessageDeltaContent {
  /** The type of content for this content part, which is always "text." */
  type: "text";

  /** The text content details. */
  text?: MessageDeltaTextContentObject;
}

/** Represents the data of a streamed text content part within a streaming message delta chunk. */
model MessageDeltaTextContentObject {
  /** The data that makes up the text. */
  value?: string;

  /** Annotations for the text. */
  annotations?: MessageDeltaTextAnnotation[];
}

/** The abstract base representation of a streamed text content part's text annotation. */
@discriminator("type")
model MessageDeltaTextAnnotation {
  /** The index of the annotation within a text content part. */
  index: int32;

  /** The type of the text content annotation. */
  #suppress "@azure-tools/typespec-azure-core/no-string-discriminator" "Existing"
  type: string;
}

@doc("A citation within the message that points to a specific URL associated with the message. Generated when the agent uses tools such as 'bing_grounding' to search the Internet.")
model MessageDeltaTextUrlCitationAnnotation extends MessageDeltaTextAnnotation {
  @doc("The object type, which is always 'url_citation'.")
  type: "url_citation";

  @encodedName("application/json", "url_citation")
  @doc("The details of the URL citation.")
  urlCitation: MessageDeltaTextUrlCitationDetails;

  @encodedName("application/json", "start_index")
  @doc("The first text index associated with this text annotation.")
  startIndex?: int32;

  @encodedName("application/json", "end_index")
  @doc("The last text index associated with this text annotation.")
  endIndex?: int32;
}

@doc("A representation of a URL citation, as used in text thread message content.")
model MessageDeltaTextUrlCitationDetails {
  @doc("The URL associated with this citation.")
  url: string;

  @doc("The title of the URL.")
  title?: string;
}

/** Represents a streamed file citation applied to a streaming text content part. */
model MessageDeltaTextFileCitationAnnotation
  extends MessageDeltaTextAnnotation {
  /** The type of the text content annotation, which is always "file_citation." */
  type: "file_citation";

  /** The file citation information. */
  @encodedName("application/json", "file_citation")
  fileCitation?: MessageDeltaTextFileCitationAnnotationObject;

  /** The text in the message content that needs to be replaced */
  text?: string;

  /** The start index of this annotation in the content text. */
  @encodedName("application/json", "start_index")
  startIndex?: int32;

  /** The end index of this annotation in the content text. */
  @encodedName("application/json", "end_index")
  endIndex?: int32;
}

/** Represents the data of a streamed file citation as applied to a streaming text content part. */
model MessageDeltaTextFileCitationAnnotationObject {
  /** The ID of the specific file the citation is from. */
  @encodedName("application/json", "file_id")
  fileId?: string;

  /** The specific quote in the cited file. */
  quote?: string;
}

/** Represents a streamed file path annotation applied to a streaming text content part. */
model MessageDeltaTextFilePathAnnotation extends MessageDeltaTextAnnotation {
  /** The type of the text content annotation, which is always "file_path." */
  type: "file_path";

  /** The file path information. */
  @encodedName("application/json", "file_path")
  filePath?: MessageDeltaTextFilePathAnnotationObject;

  /** The start index of this annotation in the content text. */
  @encodedName("application/json", "start_index")
  startIndex?: int32;

  /** The end index of this annotation in the content text. */
  @encodedName("application/json", "end_index")
  endIndex?: int32;

  /** The text in the message content that needs to be replaced */
  text?: string;
}

/** Represents the data of a streamed file path annotation as applied to a streaming text content part. */
model MessageDeltaTextFilePathAnnotationObject {
  /** The file ID for the annotation. */
  @encodedName("application/json", "file_id")
  fileId?: string;
}
