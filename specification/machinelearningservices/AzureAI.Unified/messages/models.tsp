import "../main.tsp";
import "../tools/models.tsp";

import "@typespec/versioning";

namespace Microsoft.MachineLearningServices;

using TypeSpec.Versioning;

@doc("A single message within an assistant thread, as provided during that thread's creation for its initial state.")
model ThreadMessageOptions {
  @doc("""
    The role of the entity that is creating the message. Allowed values include:
      - `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages.
      - `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into
        the conversation.
    """)
  role: MessageRole;

  @doc("""
    The textual content of the initial message. Currently, robust input including images and annotated text may only be provided via
    a separate call to the create message API.
    """)
  content: string;

  #suppress "@azure-tools/typespec-azure-core/no-nullable" "OpenAI uses explicit nullability, distinct from optionality"
  @doc("A list of files attached to the message, and the tools they should be added to.")
  attachments?: MessageAttachment[] | null;

  ...OptionalNullableMetadata;
}

@doc("A single, existing message within an assistant thread.")
model ThreadMessage {
  @doc("The identifier, which can be referenced in API endpoints.")
  id: string;

  @doc("The object type, which is always 'thread.message'.")
  object: "thread.message";

  @encodedName("application/json", "created_at")
  @encode(DateTimeKnownEncoding.unixTimestamp, int32)
  @doc("The Unix timestamp, in seconds, representing when this object was created.")
  createdAt: utcDateTime;

  @encodedName("application/json", "thread_id")
  @doc("The ID of the thread that this message belongs to.")
  threadId: string;

  @doc("The status of the message.")
  status: MessageStatus;

  #suppress "@azure-tools/typespec-azure-core/no-nullable" "OpenAI uses explicit nullability, distinct from optionality"
  @doc("On an incomplete message, details about why the message is incomplete.")
  @encodedName("application/json", "incomplete_details")
  incompleteDetails: MessageIncompleteDetails | null;

  #suppress "@azure-tools/typespec-azure-core/no-nullable" "OpenAI uses explicit nullability, distinct from optionality"
  @doc("The Unix timestamp (in seconds) for when the message was completed.")
  @encode(DateTimeKnownEncoding.unixTimestamp, int32)
  @encodedName("application/json", "completed_at")
  completedAt: utcDateTime | null;

  #suppress "@azure-tools/typespec-azure-core/no-nullable" "OpenAI uses explicit nullability, distinct from optionality"
  @doc("The Unix timestamp (in seconds) for when the message was marked as incomplete.")
  @encode(DateTimeKnownEncoding.unixTimestamp, int32)
  @encodedName("application/json", "incomplete_at")
  incompleteAt: utcDateTime | null;

  @doc("The role associated with the assistant thread message.")
  role: MessageRole;

  @doc("The list of content items associated with the assistant thread message.")
  content: MessageContent[];

  #suppress "@azure-tools/typespec-azure-core/no-nullable" "OpenAI uses explicit nullability, distinct from optionality"
  @doc("If applicable, the ID of the assistant that authored this message.")
  @encodedName("application/json", "assistant_id")
  assistantId: string | null;

  #suppress "@azure-tools/typespec-azure-core/no-nullable" "OpenAI uses explicit nullability, distinct from optionality"
  @doc("If applicable, the ID of the run associated with the authoring of this message.")
  @encodedName("application/json", "run_id")
  runId: string | null;

  #suppress "@azure-tools/typespec-azure-core/no-nullable" "OpenAI uses explicit nullability, distinct from optionality"
  @doc("A list of files attached to the message, and the tools they were added to.")
  attachments: MessageAttachment[] | null;

  ...RequiredNullableMetadata;
}

@doc("This describes to which tools a file has been attached.")
model MessageAttachment {
  @doc("The ID of the file to attach to the message.")
  @encodedName("application/json", "file_id")
  fileId: string;

  @doc("The tools to add to this file.")
  tools: MessageAttachmentToolDefinition[];
}

#suppress "@azure-tools/typespec-autorest/union-unsupported" "This union is defined according to the OpenAI API"
@doc("The possible tools to which files will be added by this message.")
union MessageAttachmentToolDefinition {
  CodeInterpreterToolDefinition | FileSearchToolDefinition,
}

// Message content types: "text" | "image_file"

@discriminator("type")
@doc("An abstract representation of a single item of thread message content.")
model MessageContent {
  #suppress "@azure-tools/typespec-azure-core/no-string-discriminator" "Existing"
  @doc("The object type.")
  type: string;
}

@doc("A representation of a textual item of thread message content.")
model MessageTextContent extends MessageContent {
  @doc("The object type, which is always 'text'.")
  type: "text";

  @doc("The text and associated annotations for this thread message content item.")
  text: MessageTextDetails;
}

@doc("A representation of image file content in a thread message.")
model MessageImageFileContent extends MessageContent {
  @doc("The object type, which is always 'image_file'.")
  type: "image_file";

  @encodedName("application/json", "image_file")
  @doc("The image file for this thread message content item.")
  imageFile: MessageImageFileDetails;
}

// Text content details

@doc("The text and associated annotations for a single item of assistant thread message content.")
model MessageTextDetails {
  @doc("The text data.")
  value: string;

  @doc("A list of annotations associated with this text.")
  annotations: MessageTextAnnotation[];
}

// Annotations, used by text content: "file_citation" | "file_path"

@discriminator("type")
@doc("An abstract representation of an annotation to text thread message content.")
model MessageTextAnnotation {
  #suppress "@azure-tools/typespec-azure-core/no-string-discriminator" "Existing"
  @doc("The object type.")
  type: string;

  @doc("The textual content associated with this text annotation item.")
  text: string;
}

// File citation annotation + details

@doc("A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the 'file_search' tool to search files.")
model MessageTextFileCitationAnnotation extends MessageTextAnnotation {
  @doc("The object type, which is always 'file_citation'.")
  type: "file_citation";

  @encodedName("application/json", "file_citation")
  @doc("""
    A citation within the message that points to a specific quote from a specific file.
    Generated when the assistant uses the "file_search" tool to search files.
    """)
  fileCitation: MessageTextFileCitationDetails;

  @encodedName("application/json", "start_index")
  @doc("The first text index associated with this text annotation.")
  startIndex?: int32;

  @encodedName("application/json", "end_index")
  @doc("The last text index associated with this text annotation.")
  endIndex?: int32;
}

@doc("A representation of a file-based text citation, as used in a file-based annotation of text thread message content.")
model MessageTextFileCitationDetails {
  @encodedName("application/json", "file_id")
  @doc("The ID of the file associated with this citation.")
  fileId: string;

  @doc("The specific quote cited in the associated file.")
  quote: string;
}

// File path annotation + details

@doc("A citation within the message that points to a file located at a specific path.")
model MessageTextFilePathAnnotation extends MessageTextAnnotation {
  @doc("The object type, which is always 'file_path'.")
  type: "file_path";

  @encodedName("application/json", "file_path")
  @doc("A URL for the file that's generated when the assistant used the code_interpreter tool to generate a file.")
  filePath: MessageTextFilePathDetails;

  @encodedName("application/json", "start_index")
  @doc("The first text index associated with this text annotation.")
  startIndex?: int32;

  @encodedName("application/json", "end_index")
  @doc("The last text index associated with this text annotation.")
  endIndex?: int32;
}

@doc("An encapsulation of an image file ID, as used by message image content.")
model MessageTextFilePathDetails {
  @doc("The ID of the specific file that the citation is from.")
  @encodedName("application/json", "file_id")
  fileId: string;
}

// Image file content details

@doc("An image reference, as represented in thread message content.")
model MessageImageFileDetails {
  @encodedName("application/json", "file_id")
  @doc("The ID for the file associated with this image.")
  fileId: string;
}

@doc("The possible execution status values for a thread message.")
union MessageStatus {
  string,

  @doc("A run is currently creating this message.")
  inProgress: "in_progress",

  @doc("This message is incomplete. See incomplete_details for more information.")
  incomplete: "incomplete",

  @doc("This message was successfully completed by a run.")
  completed: "completed",
}

@doc("Information providing additional detail about a message entering an incomplete status.")
model MessageIncompleteDetails {
  @doc("The provided reason describing why the message was marked as incomplete.")
  reason: MessageIncompleteDetailsReason;
}

@doc("A set of reasons describing why a message is marked as incomplete.")
union MessageIncompleteDetailsReason {
  string,

  @doc("The run generating the message was terminated due to content filter flagging.")
  contentFilter: "content_filter",

  @doc("The run generating the message exhausted available tokens before completion.")
  maxTokens: "max_tokens",

  @doc("The run generating the message was cancelled before completion.")
  runCancelled: "run_cancelled",

  @doc("The run generating the message failed.")
  runFailed: "run_failed",

  @doc("The run generating the message expired.")
  runExpired: "run_expired",
}
//
// These types are specifically used for streaming.
//
@doc("Represents a message delta i.e. any changed fields on a message during streaming.")
model MessageDeltaChunk {
  @doc("The identifier of the message, which can be referenced in API endpoints.")
  id: string;

  @doc("The object type, which is always `thread.message.delta`.")
  object: "thread.message.delta";

  @doc("The delta containing the fields that have changed on the Message.")
  delta: MessageDelta;
}

@doc("Represents the typed 'delta' payload within a streaming message delta chunk.")
model MessageDelta {
  @doc("The entity that produced the message.")
  role: MessageRole;

  @doc("The content of the message as an array of text and/or images.")
  content: MessageDeltaContent[];
}

@doc("The abstract base representation of a partial streamed message content payload.")
@discriminator("type")
model MessageDeltaContent {
  @doc("The index of the content part of the message.")
  index: int32;

  #suppress "@azure-tools/typespec-azure-core/no-string-discriminator" "Existing"
  @doc("The type of content for this content part.")
  type: string;
}

@doc("Represents a streamed image file content part within a streaming message delta chunk.")
model MessageDeltaImageFileContent extends MessageDeltaContent {
  @doc("The type of content for this content part, which is always 'image_file'.")
  type: "image_file";

  @doc("The image_file data.")
  @encodedName("application/json", "image_file")
  imageFile?: MessageDeltaImageFileContentObject;
}

@doc("Represents the 'image_file' payload within streaming image file content.")
model MessageDeltaImageFileContentObject {
  @doc("The file ID of the image in the message content.")
  @encodedName("application/json", "file_id")
  fileId?: string;
}

@doc("Represents a streamed text content part within a streaming message delta chunk.")
model MessageDeltaTextContentObject extends MessageDeltaContent {
  @doc("The type of content for this content part, which is always 'text'.")
  type: "text";

  @doc("The text content details.")
  text?: MessageDeltaTextContent;
}

@doc("Represents the data of a streamed text content part within a streaming message delta chunk.")
model MessageDeltaTextContent {
  @doc("The data that makes up the text.")
  value?: string;

  @doc("Annotations for the text.")
  annotations?: MessageDeltaTextAnnotation[];
}

@doc("The abstract base representation of a streamed text content part's text annotation.")
@discriminator("type")
model MessageDeltaTextAnnotation {
  @doc("The index of the annotation within a text content part.")
  index: int32;

  #suppress "@azure-tools/typespec-azure-core/no-string-discriminator" "Existing"
  @doc("The type of the text content annotation.")
  type: string;
}

@doc("Represents a streamed file citation applied to a streaming text content part.")
model MessageDeltaTextFileCitationAnnotationObject
  extends MessageDeltaTextAnnotation {
  @doc("The type of the text content annotation, which is always 'file_citation'.")
  type: "file_citation";

  @doc("The file citation information.")
  @encodedName("application/json", "file_citation")
  fileCitation?: MessageDeltaTextFileCitationAnnotation;

  @doc("The text in the message content that needs to be replaced.")
  text?: string;

  @doc("The start index of this annotation in the content text.")
  @encodedName("application/json", "start_index")
  startIndex?: int32;

  @doc("The end index of this annotation in the content text.")
  @encodedName("application/json", "end_index")
  endIndex?: int32;
}

@doc("Represents the data of a streamed file citation as applied to a streaming text content part.")
model MessageDeltaTextFileCitationAnnotation {
  @doc("The ID of the specific file the citation is from.")
  @encodedName("application/json", "file_id")
  fileId?: string;

  @doc("The specific quote in the cited file.")
  quote?: string;
}

@doc("Represents a streamed file path annotation applied to a streaming text content part.")
model MessageDeltaTextFilePathAnnotationObject
  extends MessageDeltaTextAnnotation {
  @doc("The type of the text content annotation, which is always 'file_path'.")
  type: "file_path";

  @doc("The file path information.")
  @encodedName("application/json", "file_path")
  filePath?: MessageDeltaTextFilePathAnnotation;

  @doc("The start index of this annotation in the content text.")
  @encodedName("application/json", "start_index")
  startIndex?: int32;

  @doc("The end index of this annotation in the content text.")
  @encodedName("application/json", "end_index")
  endIndex?: int32;

  @doc("The text in the message content that needs to be replaced.")
  text?: string;
}

@doc("Represents the data of a streamed file path annotation as applied to a streaming text content part.")
model MessageDeltaTextFilePathAnnotation {
  @doc("The file ID for the annotation.")
  @encodedName("application/json", "file_id")
  fileId?: string;
}

@doc("A representation of the URL used for the text citation.")
model MessageDeltaTextUrlCitationDetails {
  @doc("The URL where the citation is from.")
  url?: string;

  @doc("The title of the URL.")
  title?: string;
}
